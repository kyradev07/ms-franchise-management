name: Deploy to AWS

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

env:
  AWS_REGION: us-east-1
  PROJECT_NAME: franchise-management
  TERRAFORM_VERSION: 1.6.0

permissions:
  id-token: write   # This is required for requesting the JWT
  contents: read    # This is required for actions/checkout
  checks: write     # This is required for test reporter
  pull-requests: write  # This is required for test reporter

jobs:
  # Job para testing
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up JDK 21
      uses: actions/setup-java@v4
      with:
        java-version: '21'
        distribution: 'temurin'

    - name: Cache Gradle packages
      uses: actions/cache@v3
      with:
        path: |
          ~/.gradle/caches
          ~/.gradle/wrapper
        key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
        restore-keys: |
          ${{ runner.os }}-gradle-

    - name: Make gradlew executable
      run: chmod +x ./gradlew

    - name: Run tests
      run: ./gradlew test

    - name: Run architecture validation
      run: ./gradlew validateStructure

    - name: Generate test report
      uses: dorny/test-reporter@v1
      if: always()
      with:
        name: Gradle Tests
        path: '**/build/test-results/test/*.xml'
        reporter: java-junit

  # Job para build y deploy
  deploy:
    name: Build and Deploy
    runs-on: ubuntu-latest
    needs: test
    if: github.ref == 'refs/heads/master' && github.event_name == 'push'
    
    outputs:
      app-url: ${{ steps.terraform-output.outputs.app-url }}
      api-url: ${{ steps.terraform-output.outputs.api-url }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
        aws-region: ${{ env.AWS_REGION }}
        role-session-name: GitHubActions-${{ github.run_id }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Set up JDK 21
      uses: actions/setup-java@v4
      with:
        java-version: '21'
        distribution: 'temurin'

    - name: Cache Gradle packages
      uses: actions/cache@v3
      with:
        path: |
          ~/.gradle/caches
          ~/.gradle/wrapper
        key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
        restore-keys: |
          ${{ runner.os }}-gradle-

    - name: Make gradlew executable
      run: chmod +x ./gradlew

    - name: Build application
      run: ./gradlew bootJar

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TERRAFORM_VERSION }}
        terraform_wrapper: false

    - name: Terraform Init
      working-directory: ./terraform
      run: |
        terraform init \
          -backend-config="bucket=${{ secrets.TERRAFORM_STATE_BUCKET }}" \
          -backend-config="key=${{ env.PROJECT_NAME }}/terraform.tfstate" \
          -backend-config="region=${{ env.AWS_REGION }}" \
          -backend-config="encrypt=true" \
          -backend-config="dynamodb_table=${{ secrets.TERRAFORM_LOCK_TABLE }}"

    - name: Terraform Validate
      working-directory: ./terraform
      run: terraform validate

    - name: Clean up service-linked roles from state
      working-directory: ./terraform
      run: |
        # Remove service-linked roles from Terraform state (they already exist in AWS)
        terraform state rm aws_iam_service_linked_role.ecs || true
        terraform state rm aws_iam_service_linked_role.ecs_application_autoscaling || true
        terraform state rm aws_iam_service_linked_role.elasticloadbalancing || true
        echo "Service-linked roles removed from state"

    - name: Terraform Plan
      working-directory: ./terraform
      run: |
        terraform plan \
          -var="project_name=${{ env.PROJECT_NAME }}" \
          -var="aws_region=${{ env.AWS_REGION }}" \
          -var="environment=prod" \
          -var="github_repository=${{ github.repository }}" \
          -var="mongodb_password=${{ secrets.MONGODB_PASSWORD }}" \
          -out=tfplan

    - name: Terraform Apply
      working-directory: ./terraform
      run: terraform apply -auto-approve tfplan

    - name: Get Terraform Outputs
      id: terraform-output
      working-directory: ./terraform
      run: |
        ECR_URL=$(terraform output -raw ecr_repository_url)
        APP_URL=$(terraform output -raw application_url)
        API_URL=$(terraform output -raw api_base_url)
        
        echo "ecr-url=$ECR_URL" >> $GITHUB_OUTPUT
        echo "app-url=$APP_URL" >> $GITHUB_OUTPUT
        echo "api-url=$API_URL" >> $GITHUB_OUTPUT
        
        echo "ECR Repository: $ECR_URL"
        echo "Application URL: $APP_URL"
        echo "API Base URL: $API_URL"

    - name: Build Docker image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: ${{ env.PROJECT_NAME }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest

    - name: Push Docker image to ECR
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: ${{ env.PROJECT_NAME }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest

    - name: Update ECS service
      run: |
        CLUSTER_NAME=$(terraform -chdir=./terraform output -raw ecs_cluster_name)
        SERVICE_NAME=$(terraform -chdir=./terraform output -raw ecs_service_name)
        
        aws ecs update-service \
          --cluster $CLUSTER_NAME \
          --service $SERVICE_NAME \
          --force-new-deployment \
          --region ${{ env.AWS_REGION }}

    - name: Wait for deployment to complete
      run: |
        CLUSTER_NAME=$(terraform -chdir=./terraform output -raw ecs_cluster_name)
        SERVICE_NAME=$(terraform -chdir=./terraform output -raw ecs_service_name)
        
        echo "Waiting for service to become stable..."
        aws ecs wait services-stable \
          --cluster $CLUSTER_NAME \
          --services $SERVICE_NAME \
          --region ${{ env.AWS_REGION }}
        
        echo "Deployment completed successfully!"

    - name: Verify deployment
      run: |
        APP_URL="${{ steps.terraform-output.outputs.app-url }}"
        HEALTH_URL="$APP_URL/actuator/health"
        
        echo "Verifying application health at: $HEALTH_URL"
        
        # Wait up to 5 minutes for the application to be healthy
        for i in {1..30}; do
          if curl -f -s "$HEALTH_URL" > /dev/null; then
            echo "âœ… Application is healthy!"
            curl -s "$HEALTH_URL" | jq .
            break
          else
            echo "â³ Waiting for application to be ready... (attempt $i/30)"
            sleep 10
          fi
          
          if [ $i -eq 30 ]; then
            echo "âŒ Application health check failed after 5 minutes"
            exit 1
          fi
        done

  # Job para notificaciÃ³n de Ã©xito
  notify-success:
    name: Notify Deployment Success
    runs-on: ubuntu-latest
    needs: deploy
    if: success()
    
    steps:
    - name: Create deployment summary
      run: |
        cat >> $GITHUB_STEP_SUMMARY << EOF
        # ðŸš€ Deployment Successful!
        
        ## ðŸ“Š Deployment Information
        - **Environment**: Production
        - **Commit**: ${{ github.sha }}
        - **Branch**: ${{ github.ref_name }}
        - **Workflow**: ${{ github.workflow }}
        
        ## ðŸŒ Application URLs
        - **Application**: ${{ needs.deploy.outputs.app-url }}
        - **API Base**: ${{ needs.deploy.outputs.api-url }}
        - **Health Check**: ${{ needs.deploy.outputs.app-url }}/actuator/health
        
        ## ðŸ“‹ Available Endpoints
        - \`POST\` ${{ needs.deploy.outputs.api-url }}/franchise
        - \`PUT\` ${{ needs.deploy.outputs.api-url }}/franchise/{id}
        - \`POST\` ${{ needs.deploy.outputs.api-url }}/franchise/{franchiseId}/branch
        - \`PUT\` ${{ needs.deploy.outputs.api-url }}/franchise/{franchiseId}/branch/{branchId}
        - \`POST\` ${{ needs.deploy.outputs.api-url }}/franchise/{franchiseId}/branch/{branchId}/product
        - \`PUT\` ${{ needs.deploy.outputs.api-url }}/franchise/{franchiseId}/branch/{branchId}/product/{productId}
        - \`DELETE\` ${{ needs.deploy.outputs.api-url }}/franchise/{franchiseId}/branch/{branchId}/product/{productId}
        - \`GET\` ${{ needs.deploy.outputs.api-url }}/franchise/{franchiseId}
        
        ## ðŸ§ª Test the API
        \`\`\`bash
        # Health check
        curl ${{ needs.deploy.outputs.app-url }}/actuator/health
        
        # Create franchise
        curl -X POST ${{ needs.deploy.outputs.api-url }}/franchise \\
          -H "Content-Type: application/json" \\
          -d '{"name":"Test Franchise","id":""}'
        \`\`\`
        
        ðŸŽ‰ **Your application is now live and accessible from anywhere in the world!**
        EOF

  # Job para manejar fallos
  notify-failure:
    name: Notify Deployment Failure
    runs-on: ubuntu-latest
    needs: [test, deploy]
    if: failure()
    
    steps:
    - name: Create failure summary
      run: |
        cat >> $GITHUB_STEP_SUMMARY << EOF
        # âŒ Deployment Failed
        
        ## ðŸ“Š Failure Information
        - **Commit**: ${{ github.sha }}
        - **Branch**: ${{ github.ref_name }}
        - **Workflow**: ${{ github.workflow }}
        - **Failed Job**: ${{ needs.test.result == 'failure' && 'Tests' || 'Deployment' }}
        
        ## ðŸ” Next Steps
        1. Check the logs above for specific error messages
        2. Verify AWS credentials and permissions
        3. Ensure Terraform state bucket exists
        4. Check if MongoDB password secret is set
        5. Validate code changes don't break tests
        
        ## ðŸ› ï¸ Common Issues
        - **Test failures**: Check unit tests and fix failing code
        - **AWS permissions**: Ensure the IAM role has necessary permissions
        - **Terraform state**: Verify S3 bucket and DynamoDB table exist
        - **ECR push**: Check if ECR repository was created successfully
        
        Please review the error logs and try again.
        EOF